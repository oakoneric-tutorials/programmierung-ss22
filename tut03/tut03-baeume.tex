% This work is licensed under the Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy
% of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or
% send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

% (c) Eric Kunze, 2019

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Template for lecture notes and exercises at TU Dresden.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[ngerman, a4paper, 11pt]{article}

\usepackage[ngerman]{babel}
\usepackage[top=2.5cm,bottom=2.5cm,left=2.5cm,right=2.5cm]{geometry}
\usepackage{parskip}
\usepackage[onehalfspacing]{setspace} % increase row-space
\usepackage[utf8]{inputenc}


\usepackage{lmodern}
\usepackage{ulem} 

\usepackage{fancyhdr} 	% customize header / footer

\usepackage{amsmath,amssymb,amsfonts,mathtools}
%\usepackage{blkarray}
\usepackage{latexsym, marvosym, wasysym, stmaryrd}
\usepackage{bbm} 		% unitary matrix


% further support for different equation setting
\usepackage{cancel}
\usepackage{xfrac}		% sfrac -> fractions e.g. 3/4
\usepackage{diagbox}

\usepackage{../mathoperatorsAuD}

\usepackage[table,dvipsnames]{tudscrcolor}
\usepackage{tabularx} 	% tabularx-environment (explicitly set width of columns)
\usepackage{multirow}
\usepackage{booktabs}	% improved rules


\newcommand{\begriff}[1]{\textbf{#1}}
\newcommand{\person}[1]{\textsc{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                             COUNTER                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{chngcntr}
\usepackage{enumerate}
\usepackage[inline]{enumitem} 		%customize label

\pretocmd{\chapter}{\setcounter{section}{0}}{}{}
\pretocmd{\chapter}{\setcounter{equation}{0}}{}{}

\renewcommand{\labelitemi}{\raisebox{2pt}{\scalebox{.4}{$\blacksquare$}}}
\renewcommand{\labelitemii}{$\vartriangleright$}
\renewcommand{\labelitemiii}{--}
% Variantionen des Dreiecks als Aufzählungszeichen $\blacktriangleright$ / $\vartriangleright$ / $\triangleright$

\renewcommand{\labelenumi}{(\arabic{enumi})}
\renewcommand{\labelenumii}{\alph{enumii}.}
\renewcommand{\labelenumiii}{\roman{enumiii}.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{titlesec}   % change title headings look
\usepackage{chngcntr}   % modify counters
\usepackage{relsize}    % relative font size (smaller[i], larger[i], ...)

\titleformat{\section}[hang]{\bfseries\LARGE\centering}{\thesection}{8pt}{}
%\titleformat*{\section}{\bfseries\titlefont\sectionsize}
\titleformat*{\subsection}{\sffamily\itshape\large\centering}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{listings}
\lstdefinestyle{noframe}{
	basicstyle=\small\ttfamily,        % the size of the fonts that are used for the code
	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
	breaklines=true,                 % sets automatic line breaking
	commentstyle=\itshape,    	     % comment style
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
	firstnumber=1,                % start line enumeration with line 1000
	frame=none,
	keywordstyle=\bfseries,       % keyword style 
	language=Haskell,                 % the language of the code
	numbers=none,                    % where to put the line-numbers; possible: (none, left, right)
	tabsize=2,	                   % sets default tabsize to 2 spaces
}
\lstdefinestyle{frame}{
	basicstyle=\footnotesize\ttfamily,        % the size of the fonts that are used for the code
	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
	breaklines=true,                 % sets automatic line breaking
	commentstyle=\itshape,    	     % comment style
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
	firstnumber=1,                % start line enumeration with line 1000
	frame=single,
	keywordstyle=\bfseries,       % keyword style
	morekeywords={}, 
	language=Haskell,                 % the language of the code
	numbers=left,                    % where to put the line-numbers; possible: (none, left, right)
	numbersep=5pt,                   % how far the line-numbers are from the code
	numberstyle=\tiny\color{cdgray!50}, % the style that is used for the line-numbers
	rulecolor=\color{cddarkblue}, 
	tabsize=2,	                   % sets default tabsize to 2 spaces
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THEOREM ENVIRONMENTS // MATH

\usepackage{ntheorem}

\DeclareMathSymbol{*}{\mathbin}{symbols}{"01}

\counterwithin{equation}{section}
\newcounter{themcount}
\counterwithin{themcount}{section}

\newcommand{\skiparound}{10pt}
\theorempreskip{\skiparound}
\theorempostskip{\skiparound}

\theoremstyle{nonumberplain}
\theoremseparator{.}
\theorembodyfont{}

\newtheorem{aufgabe}{Aufgabe}
\theorembodyfont{\itshape}
\newtheorem{bemerkung}[themcount]{Bemerkung}

\usepackage[
	type={CC},
	modifier={by-nc-sa},
	version={4.0},
]{doclicense}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           REFERENCES                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[unicode,bookmarks=true]{hyperref}
\hypersetup{
	% pdfborder={0 0 0}			% no boxed around links
	pdfborderstyle={/S/U/W 1},	% underlining insteas of boxes
	linkbordercolor=cdblue,
	urlbordercolor=cdblue
}

\usepackage{cleveref}
\crefname{bemerkung}{Bemerkung}{Bemerkungen}

\usepackage{bookmark}		% pdf-bookmarks

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      ADDITIONAL COMMANDS                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand*\ruleline[1]{\par\noindent\raisebox{.8ex}{\makebox[\linewidth]{\hrulefill\hspace{1ex}\raisebox{-.8ex}{#1}\hspace{1ex}\hrulefill}}}

\usepackage[edges]{forest}
%\usepackage[default]{opensans}

\begin{document}
	\begin{center}
		{\bfseries \sffamily \huge Algebraische Datentypen -- Binärbäume} 
		
		\ruleline{\sffamily \Large Übungsblatt 3}
		
		{\scshape Eric Kunze --- \today}
	\end{center}
	\medskip
	
	{ \footnotesize \doclicenseThis }
	
	\begin{center}
		\small \slshape Keine Garantie auf Vollständigkeit und/oder Korrektheit!
	\end{center}
	
\section*{Aufgabe 2}

Wir betrachten den algebraischen Datentyp \texttt{BinTree} definiert durch
\begin{lstlisting}[style=noframe]
	data BinTree = Branch Int BinTree BinTree | Nil deriving Show
\end{lstlisting}
Wie versteht man nun diese Definition: entweder wir haben einen Knoten mit Beschriftung und zwei Kindern vorliegen oder der Baum ist leer bzw. als Nil kodiert.


\subsection*{Teilaufgabe (a)} \label{sec: a}

Wir wollen einen Beispielbaum anlegen. Das funktioniert im Prinzip so, dass man die Typdefinition nimmt und dann für die Typen darin konkrete Werte einsetzt. Also:
\begin{lstlisting}[style=noframe]
	mytree :: BinTree
	mytree = Branch 0 Nil Nil
\end{lstlisting}
steht zum Beispiel für den Baum, der nur eine \texttt{0} enthält. Den können wir nun immer weiter erweitern, indem wir die \texttt{Nil}'s ersetzen und dabei bisschen auf die Klammerung achten. 
\begin{lstlisting}[style=noframe]
	mytree = Branch 0 
	           ( Nil )
	           ( Branch 3 Nil Nil )
\end{lstlisting}
Um das bisschen übersichtlich zu machen, schreibt man das dann so bisschen gestaffelt untereinander (es wird zwangsweise immer bisschen unübersichtlich). Dann kann man das immer weiter ausbauen bis wir den geforderten Baum erhalten.
\begin{lstlisting}[style=frame, firstnumber=12]
	mytree = Branch 0 
	           ( Nil )
	           ( Branch 3 
	             ( Branch 1 Nil Nil )
	             ( Branch 5 Nil Nil )
	            )
\end{lstlisting}
Schreibt man das in gewohnter Schreibweise, so erhält man den Baum:

\begin{figure}[h]
	\centering
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[ $0$ [,no edge, draw=none] [ $3$ [$1$] [$5$] ] ]
	\end{forest} 
\end{figure}


\subsection*{Teilaufgabe (b)}

\begin{aufgabe}
	Geben Sie eine Haskell-Funktion einschließlich der Typ-Definition an, die testet, ob zwei Binärbäume des Typs \texttt{BinTree} identisch sind.
\end{aufgabe}

Die Typdefinition unserer Funktion \texttt{equal} ist schnell gefunden: wir brauchen zwei Bäume vom Typ \texttt{BinTree}, die miteinander verglichen werden sollen, als Argumente; und geben am Ende einen Wahrheitswert \texttt{Bool} zurück. Demnach ist die Typdefinition gegeben durch:
\begin{lstlisting}[style=noframe]
	equal :: BinTree -> BinTree -> Bool
\end{lstlisting}

Man überlegt sich leicht, dass zwei Bäume genau dann gleich sind, wenn beide Wurzelknoten die gleiche Beschriftung tragen und die beiden Kinder jeweils übereinstimmen. Somit erhält man für den Fall, dass beide Bäume mindestens einen Knoten tragen, den folgenden Rekursionsfall
\begin{lstlisting}[style=noframe]
	equal :: BinTree -> BinTree -> Bool
	equal (Branch x l1 r1) (Branch y l2 r2) = (x == y) && 
	                                          (equal l1 l2) && 
	                                          (equal r1 r2)
\end{lstlisting}
Als Basisfall würde man zunächst den offensichtlichen nehmen: beide Bäume sind leer und damit auch gleich:
\begin{lstlisting}[style=noframe]
	equal :: BinTree -> BinTree -> Bool
	equal Nil              Nil              = True
	equal (Branch x l1 r1) (Branch y l2 r2) = (x == y) && 
	                                          (equal l1 l2) && 
	                                          (equal r1 r2)
\end{lstlisting}

Aber hier gibt es eine kleine Gemeinheit. Die Funktion führt eine Rekursion über beide Bäume aus. Jetzt kann es aber auch passieren, dass beide Bäume unterschiedlich groß sind. Wenn wir nun immer wieder den Rekursionsfall anwenden, dann werden die Bäume zwar immer kleiner, aber aufgrund der unterschiedlichen Größe kann einer eher leer werden als der andere. Das ist dann in noch keinem Fall abgedeckt, weil der leere Baum dann nicht mehr die \texttt{Branch}-Struktur besitzt (Pattern Matching schlägt fehl), anderseits auch der Basisfall mit zwei leere Bäumen nicht passt, da ja einer von beiden noch nicht leer ist. Dementsprechend gibt es noch die beiden Fälle
\begin{lstlisting}[style=noframe]
	equal Nil              (Branch y l2 r2) = False
	equal (Branch x l1 r1) Nil              = False
\end{lstlisting}
Ich denke, dass die Bäume dann nicht gleich sind, ist klar (leer und nichtleer kann halt nicht gleich sein). Entweder man schreibt nun die beiden Fälle noch als Basis dazu oder man sagt, dass alles, was durch die bereits bestehenden Fälle (leer-leer und voll-voll) noch nicht abgedeckt ist (und das sind genau die beiden Fälle leer-voll und voll-leer), das wird zu \texttt{False}. Genau diese Variante ist in der Musterlösung mit den Wildcards \lstinline[style=noframe]|_| angegeben. Wildcards sind dabei Platzhalter für beliebige Werte; man könnte auch stets Variablen \texttt{t1} und \texttt{t2} anstelle derer schreiben, jedoch werden diese auf der rechten Seite ohnehin nicht zu Berechnung benötigt.

Man erhält somit eine der beiden folgenden Lösungen:
\begin{lstlisting}[style=frame]
	equal :: BinTree -> BinTree -> Bool
	equal Nil              Nil              = True
	equal Nil              (Branch y l2 r2) = False
	equal (Branch x l1 r1) Nil              = False
	equal (Branch x l1 r1) (Branch y l2 r2) = (x == y) && 
	                                          (equal l1 l2) && 
	                                          (equal r1 r2)
\end{lstlisting}
oder
\begin{lstlisting}[style=frame]
	equal :: BinTree -> BinTree -> Bool
	equal Nil              Nil              = True
	equal (Branch x l1 r1) (Branch y l2 r2) = (x == y) && 
	                                          (equal l1 l2) && 
	                                          (equal r1 r2)
	equal _                 _               = False
\end{lstlisting}


\subsection*{Teilaufgabe (c)}

\begin{aufgabe}
	Geben Sie eine Funktion \texttt{insert :: BinTree -> [Int] -> BinTree} an, die alle Werte einer Liste von Integer-Zahlen in einen bereits bestehenden Suchbaum des Typs \texttt{BinTree} so einfügt, dass die Suchbaumeigenschaft erhalten bleibt. In einem Suchbaum muss für jeden Knoten \texttt{x} gelten, dass seine Beschriftung größer oder gleich (bzw. kleiner oder gleich) allen
	Beschriftungen im linken (bzw. rechten) Teilbaum von \texttt{x} ist.
\end{aufgabe}

Wir wollen die Rekursion über die Listenstruktur laufen lassen. Eine Liste ist entweder
\begin{itemize}[nolistsep, topsep=-\parskip]
	\item die leere Liste oder
	\item sie hat mindestens ein (erstes) Element
\end{itemize}

Wenn wir die leere Liste einfügen wollen, dann musst man natürlich nichts machen außer den Baum wieder ausgeben. 
So dann zum Rekursionsfall, d.h. wir haben wirklich Elemente in der Liste, die wir einfügen wollen. Dazu kann man sich erst einmal das etwas leichtere Problem ansehen, nämlich anstatt einer ganzen Liste nur ein einzelnes Element einzufügen. Dies erledigt die Funktion
\begin{lstlisting}[style=noframe]
	insertSingle :: BinTree -> Int -> BinTree
\end{lstlisting}
für uns. Der Basisfall dort ist wieder relativ einfach einzusehen, d.h. wenn wir in einen leeren Baum ein Element einfügen wollen, dann erstellen wir einen Knoten mit entsprechender Beschriftung und leeren Kindern:
\begin{lstlisting}[style=noframe]
	insertSingle :: BinTree -> Int -> BinTree
	insertSingle Nil            x = Branch x Nil Nil
\end{lstlisting}
Betrachten wir den Rekursionsfall von \texttt{insertSingle}. Nehmen wir an, dass wir im Baum mindestens einen Knoten vorliegen haben; dieser trägt eine Beschriftung \texttt{y} und einen linkes Kind \texttt{l} sowie ein rechtes Kind \texttt{r}. Wollen wir nun dort ein Schlüssel (= Knotenbeschriftung) \texttt{x} korrekt einfügen. 
\begin{lstlisting}[style=noframe]
	insertSingle :: BinTree -> Int -> BinTree
	insertSingle Nil            x = Branch x Nil Nil
	insertSingle (Branch y l r) x = ...
\end{lstlisting}
Nun machen wir uns die Eigenschaft eines Suchbaums zu Nutze, dass in \texttt{l} alle Schlüssel kleiner sind als \texttt{y} und in \texttt{r} alle Schlüssel größer sind als \texttt{y}. Dementsprechend müssen wir an jedem Knoten entscheiden, ob wir in den linken oder rechten Teilbaum einfügen wollen. 
\begin{itemize}
	\item Ist das einzufügende Element \texttt{x} kleiner als \texttt{y}, dann gehört es per Definition des Suchbaums in den linken Teilbaum. Also gestalten wir uns einen \enquote{neuen} Knoten, der die gleiche Beschriftung \texttt{y} trägt und auch den gleichen rechten Teilbaum \texttt{r}, da wir dort ja nichts verändert haben. Den linken Teilbaum müssen wir aber verändern, nämlich so, dass dort \texttt{x} eingefügt wird -– das ist aber das bekannte Problem \enquote{Einfügen eines Schlüssels in einen Baum} und das macht uns die Funktion \texttt{insertSingle}. Daher kommt also die Zeile 
	\begin{lstlisting}[style=noframe]
		insertSingle :: BinTree -> Int -> BinTree
		insertSingle Nil            x = Branch x Nil Nil
		insertSingle (Branch y l r) x
			| x < y     = Branch y (insertSingle l x) r
	\end{lstlisting}
	\item In dem Fall, dass der einzufügende Schlüssel x größer ist als y, dann gehen wir analog vor, verändern jedoch nicht den linken, sondern den rechten Teilbaum, also:
	\begin{lstlisting}[style=noframe]
		insertSingle :: BinTree -> Int -> BinTree
		insertSingle Nil            x = Branch x Nil Nil
		insertSingle (Branch y l r) x
			| x < y     = Branch y (insertSingle l x) r
			| otherwise = Branch y l (insertSingle r x)
	\end{lstlisting}
\end{itemize}

Damit haben wir also das Problem \enquote{Einfügen eines Schlüssels in einen Baum} mithilfe von insertSingle gelöst. Dann müssen wir uns jetzt noch darum kümmern, dass wir von der Liste in \texttt{insert} zum einzelnen Element in \texttt{insertSingle} kommen. Das läuft aber relativ einfach als Rekursion über die Listenstruktur. Wir teilen die Liste also auf in \texttt{(x:xs)}, spalten also ein erstes Element ab. Nun wollen wir das \texttt{x} als einzelnes Element einfügen via \texttt{insertSingle t x} und bekommen dann aber schon einen neuen Baum, den wir \texttt{t'} nennen. Wenn wir die restlichen Elemente von \texttt{xs} einfügen wollen, dann müssen wir aufpassen und müssen diese in \texttt{t'} und nicht in \texttt{t} einfügen. Da entsteht dann der rekursive Aufruf \texttt{insert t' xs}. Die Auslagerung der Berechnung von \texttt{t'} ist einfach eine kleine Feinheit, die ich für bisschen verständlicher halte, man kann auch die rechte Seite von \texttt{t'} direkt in den rekursiven Aufruf packen wie in der Musterlösung.

Damit erhalten wir also als Lösung der Aufgabe:
\begin{lstlisting}[style=frame]
insert :: BinTree -> [Int] -> BinTree
insert t []     = t
insert t (x:xs) = insert t' xs
	where
		t' = insertSingle t x
		insertSingle :: BinTree -> Int -> BinTree
		insertSingle            Nil x = Branch x Nil Nil
		insertSingle (Branch y l r) x
			|     x < y = Branch y (insertSingle l x)                  r
			| otherwise = Branch y                  l (insertSingle r x)
\end{lstlisting}

Wir wollen nun diese Funktion mit unserem Beispielbaum \texttt{mytree} aus Teil (a) testen.
Damit dann auch die Ausgabe klappt, wenn wir unsere Funktion mit \texttt{ghci} testen, müssen wir noch eine klein wenig die Typdefinition ändern:
\begin{lstlisting}[style=noframe]
	data BinTree = Branch Int BinTree BinTree | Nil deriving Show
\end{lstlisting}
Die Direktive \texttt{Show} sorgt einfach dafür, dass eine standardmäßige (trotzdem relativ hässliche) Ausgaberoutine bereitgestellt wird.
Damit können wir jetzt in \texttt{ghci} testen, z.B. mit dem Aufruf \texttt{insert testTree [9,12]}

\begin{bemerkung}[Suchbäume]
	In der Regel betrachtet man Suchbäume ohne Dopplungen, d.h. jede Zahl sollte nur einmal vorkommen. Dementsprechend macht es wenig Sinn eine bereits bestehende Zahl einzufügen. 
\end{bemerkung}

\subsection{Teilaufgabe (d)}

\begin{aufgabe}
	Geben Sie eine Funktion \texttt{unwind :: BinTree -> [Int]} an, welche einen gegebenen Baum ebenenweise traversiert und dabei die Liste der Knotenbeschriftungen in der Reihenfolge der Traversierung berechnet. Dabei soll zunächst die Wurzel besucht werden, dann die direkten Nachfolger der Wurzel von links nach rechts, dann deren direkte Nachfolger von links nach rechts, usw. Zum Beispiel soll für den unten stehenden Baum \texttt{tree} gelten, dass \texttt{unwind tree == [1,2,3,7,6,5,4]}.
\end{aufgabe}

\begin{figure}[h]
	\centering
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[ $1$ [$2$ [$7$] [$6$]] [ $3$ [$5$] [$4$] ] ]
	\end{forest} 
\end{figure}

Zunächst einmal ist der dargestellte Baum \texttt{tree} in Haskell wie folgt zu notieren (vgl. \cref{sec: a}):
\begin{lstlisting}[style=noframe]
tree :: BinTree
tree = Branch 1
			( Branch 2
				( Branch 7 Nil Nil ) 
				( Branch 6 Nil Nil ) )
			( Branch 3
				( Branch 5 Nil Nil )
				( Branch 4 Nil Nil ) )
\end{lstlisting}

Für Umsetzung der ebenenweisen Traversierung nutzen wir folgende Idee: wir speichern uns stets eine Liste von Bäumen. In diese Liste nehmen wir uns immer den ersten Baum heraus, fügen dessen Wurzel zur Ausgabeliste hinzu und hängen die Kindbäume hinten an die Speicherliste an -- diese werden in der nächsten Runde betrachtet. 

Wir beginnen mit der Hauptfunktion \texttt{unwind} und übergeben das Problem vollständig an die Hilfsfunktion, die wir in diesem Fall \texttt{go} nennen. Gemäß der beschriebenen Idee müssen wir dazu das Argument von \texttt{unwind}, ein Binärbaum, in eine Liste eintragen, also
\begin{lstlisting}[style=noframe]
undwind :: BinTree -> [Int]
unwind t = go [t]
\end{lstlisting} 

Nun können wir uns mit der \texttt{go}-Funktion beschäftigen. Wie bereits erwähnt ist das Argument von \texttt{go} eine Liste von Bäumen, d.h. \texttt{[BinTree]}; die Rückgabe soll und muss um mit dem Ergebnistyp von \texttt{unwind} übereinzustimmen, vom Typ \texttt{[Int]} sein. Damit ist der Typ der Funktion gegeben durch
\begin{lstlisting}[style=noframe]
go :: [BinTree] -> [Int]
\end{lstlisting}
Nun müssen wir \texttt{go} rekursiv definieren. Jedoch haben wir hier zwei rekursive Datenstrukturen vorliegen: Listen und Bäume. In diesem Beispiel wollen wir auch beide Rekursionen parallel ablaufen lassen.
Beginnen wir dazu mit der Rekursion auf der Liste (von Bäumen). Diese müssen wir für den Rekursionsfall aufspalten in Head und Tail, also in der Form \texttt{(t:ts)}. Der Basisfall für Listen sieht wie üblich die leere Liste vor. Wir brauchen also für die Listenrekursion folgende zwei Zeilen:
\begin{lstlisting}[style=noframe]
go []     = ...
go (t:ts) = ...
\end{lstlisting}
Nun bringen wir die zweite Rekursion ins Spiel: die Rekursion auf der Baumstruktur - und zwar um genau zu sein auf der Baumstruktur des ersten Baumes der Liste, also der Struktur von \texttt{t}. Im Rekursionsfall zerlegen wir diesen in einen Knoten mit Beschriftung \texttt{x} und zwei Kindern \texttt{l} und \texttt{r}, d.h. in $\texttt{t} = \texttt{Branch x l r}$; im Basisfall ist dieser Baum leer, d.h. $\texttt{t} = \texttt{Nil}$. Damit zerlegt sich die bisherige zweite Zeile in zwei weitere Zeilen:
\begin{lstlisting}[style=noframe]
go []     = ...
go ( Nil           : ts) = ...
go ((Branch x l r) : ts) = ...
\end{lstlisting}
Damit ist das Grundgerüst für die Funktion gebaut. Wir müssen uns \enquote{nur} noch Gedanken für die jeweiligen Rückgaben auf der rechten Seite machen. Also los geht's \dots

Wir erinnern uns, dass jeder nichtleere Baum in genau drei Teile zerlegt werden kann: ein Wurzelknoten und ein linkes sowie ein rechtes Kind. Auf diese drei Teile haben wir im Rekursionsfall Zugriff und können sie neu anordnen. Der Wurzelknoten \texttt{x} soll natürlich direkt in die Ausgabeliste wandern. Diese Ausgabeliste ist die Rückgabe von \texttt{go}, also können wir dieses \texttt{x} als Head der Ausgabeliste \enquote{konstruieren}. Die beiden Kindbäume müssen wir an unsere Baum-Speicher-Liste anhängen. Bisher bestand diese Liste aus dem ersten Baum, den wir gerade zerlegen, und den Restbäumen in der Liste \texttt{ts}. Den ersten Baum haben wir soeben abgearbeitet, also entfällt dieser; \texttt{ts} verbleibt; die Bäume \texttt{l} und \texttt{r} hängen wir als zweielementige Liste \texttt{[l, r]} hinten an \texttt{ts} an. Insgesamt haben wir bisher folgendes Ergebnis:
\begin{lstlisting}[style=noframe]
go []                    = ...
go ( Nil           : ts) = ...
go ((Branch x l r) : ts) = x : go (ts ++ [l, r])
\end{lstlisting}
Treffen wir in unserer Merkliste auf einen leeren Baum, dann hat dieser schon keinen Knoten mehr, den wir der Ausgabeliste hinzufügen könnten, also können wir den leeren Baum einfach ignorieren:
\begin{lstlisting}[style=noframe]
go []                    = ...
go ( Nil           : ts) = go ts
go ((Branch x l r) : ts) = x : go (ts ++ [l, r])
\end{lstlisting}
Ist die Merkliste von noch verbleibenden Bäumen schließlich leer, so sind alle Knoten abgearbeitet und wir sind fertig. Da wir im Rekursionsfall immer mit dem cons-Operator einzelne Elemente hintereinander gehangen haben, müssen wir zum Abschluss noch eine leere Liste anhängen. Also:
\begin{lstlisting}[style=noframe]
go []                    = []
go ( Nil           : ts) = go ts
go ((Branch x l r) : ts) = x : go (ts ++ [l, r])
\end{lstlisting}
Die Hilfsfunktion \texttt{go} können wir nun noch in eine lokale Definition schieben und erhalten schließlich die vollständige ebenenweise Traversierung:
\begin{lstlisting}[style=frame]
undwind :: BinTree -> [Int]
unwind t = go [t]
	where
		go []                    = []
		go ( Nil           : ts) = go ts
		go ((Branch x l r) : ts) = x : go (ts ++ [l, r])
\end{lstlisting}

Um diese Funktion noch besser zu verstehen, wollen wir anhand des Beispielbaums \texttt{tree} die Abarbeitung veranschaulichen. Wir starten in \texttt{unwind} und packen den vollständigen Baum in eine Liste, also starten wir mit dem Aufruf
\begin{equation*}
	\texttt{go} \left[ 
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[ $1$ [$2$ [$7$] [$6$]] [ $3$ [$5$] [$4$] ] ]
	\end{forest} 
	\right]
\end{equation*}
Wir zerlegen den Baum in Wurzelknoten und die beiden Kinder:
\begin{equation*}
	\texttt{x} = 1, \qquad
	\texttt{l} = \begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[$2$ [$7$] [$6$]]
	\end{forest} , \qquad
	\texttt{r} = \begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[ $3$ [$5$] [$4$] ]
	\end{forest} 
\end{equation*}
Damit folgt der nächste rekursive Aufruf von \texttt{go} mit
\begin{equation*}
	\texttt{1 : go} \left[ 
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[$2$ [$7$] [$6$]]
	\end{forest} ,
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[ $3$ [$5$] [$4$] ]
	\end{forest} 
	\right]
\end{equation*}
oder in Haskell-Schreibweise
\begin{align*}
	\texttt{1 : go \Big[} &\texttt{Branch 2 (Branch 7 Nil Nil) (Branch 7 Nil Nil) , } \\
	&\texttt{Branch 3 (Branch 5 Nil Nil) (Branch 4 Nil Nil) \Big]}
\end{align*}
Nun spalten wir wieder den ersten Baum der Speicherliste in \texttt{go} ab, packen die Wurzel zur Ausgabe und die beiden Kinder hinten an die Speicherliste, also
\begin{equation*}
	\texttt{1 : 2 : go} \left[ 
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[ $3$ [$5$] [$4$] ]
	\end{forest} ,
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[$7$]
	\end{forest} ,
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[$6$]
	\end{forest}
	\right]
\end{equation*}
Im Anschluss wird auch der nächste Baum nach diesem Prinzip zerlegt und wir erhalten
\begin{equation*}
	\texttt{1 : 2 : 3 : go} \left[ 
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[$7$]
	\end{forest} ,
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[$6$]
	\end{forest} ,
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[$5$]
	\end{forest} ,
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[$4$]
	\end{forest}
	\right]
\end{equation*}
Nun kommen wir an den ersten kleinen kritischen Punkt, denn die Kinder des nächsten Baumes sind leer. Das macht in diesem Moment aber noch nichts aus, da wir dennoch den Knoten $7$ in \texttt{Branch 7 Nil Nil} aufspalten können. Damit erhalten wir im nächsten rekursiven Aufruf
\begin{equation*}
	\texttt{1 : 2 : 3 : 7 : go} \left[ 
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[$6$]
	\end{forest} ,
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[$5$]
	\end{forest} ,
	\begin{forest}
		for tree={ grow=south, circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm }
		[$4$]
	\end{forest} ,
	\texttt{Nil}, \texttt{Nil}
	\right]
\end{equation*}
Für die nächsten drei Bäume erfolgt das Spiel komplett analog und wir rufen rekursiv wie folgt auf:
\begin{equation*}
	\texttt{1 : 2 : 3 : 7 : 6 : 5 : 4 : go} \left[ 
	\texttt{Nil}, \texttt{Nil}, \enskip
	\texttt{Nil}, \texttt{Nil}, \enskip
	\texttt{Nil}, \texttt{Nil}, \enskip
	\texttt{Nil}, \texttt{Nil}
	\right]
\end{equation*}
Nun wenden wir den Baum-Basisfall an, da das erste Element der Speicherliste auf \texttt{Nil} passt und keine \texttt{Branch}-Struktur mehr aufweist. Damit entfernen wir dieses erste \texttt{Nil} und rufen \texttt{go} einfach wieder mit der verbleibenden Restliste auf ohne etwas zur Ausgabe hinzuzufügen:
\begin{equation*}
	\texttt{1 : 2 : 3 : 7 : 6 : 5 : 4 : go} \left[ 
	\texttt{Nil}, \enskip
	\texttt{Nil}, \texttt{Nil}, \enskip
	\texttt{Nil}, \texttt{Nil}, \enskip
	\texttt{Nil}, \texttt{Nil}
	\right]
\end{equation*}
Das gleiche Spiel passiert nun noch sieben Mal und wir erhalten schließlich
\begin{equation*}
	\texttt{1 : 2 : 3 : 7 : 6 : 5 : 4 : go []}
\end{equation*}
Damit können wir noch den Listen-Basisfall anwenden, der \texttt{go []} zu \texttt{[]} evaluiert:
\begin{equation*}
	\texttt{1 : 2 : 3 : 7 : 6 : 5 : 4 : []} 
\end{equation*}
Führen wir nun noch alle cons-Operatoren aus, so erhalten wir am Ende die finale Ergebnisliste \texttt{[1,2,3,7,6,5,4]}.
\end{document}

